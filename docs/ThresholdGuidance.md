# What threshold value should I choose?

There is little consensus for a specific cyclomatic complexity value that indicates that a method has become too complex. As ever, it depends. Metrics are subjective, and should always be used as guidance, to inform a decision, rather than be blindly followed. Any threshold also needs to take into account the experience of the team that maintains the code. If they are an experienced team, you might be happier to allow somewhat more complex methods than if the team were less experienced.

This thread on programmers.stackexchange.com goes into [more details about why this is a subjective metric](http://programmers.stackexchange.com/questions/194061/cyclomatic-complexity-ranges).

This plugin uses a default value of 20, for all languages. Any method or function, etc. that has a complexity greater than 20 is flagged as too complex.

To get some idea of ranges, here are some examples:

1. **NIST 500-235** - Structured Testing: A Testing Methodology Using the Cyclomatic Complexity Metric - September 1996  
   http://www.mccabe.com/pdf/mccabe-nist235r.pdf  
   Co-written by Thomas McCabe, who first introduced the cyclomatic complexity metric, this NIST paper suggests a limit of 10 (or maybe 15). See page 15:

   > The original limit of 10 as proposed by McCabe has significant supporting evidence, but limits as high as 15 have been used successfully as well. Limits over 10 should be reserved for projects that have several operational advantages over typical projects, for example experienced staff, formal design, a modern programming language, structured programming, code walkthroughs, and a comprehensive test plan. In other words, an organization can pick a complexity limit greater than 10, but only if it is sure it knows what it is doing and is willing to devote the additional testing effort required by more complex modules.

2. **C4 Software Technology Reference Guide** - 1997  
   http://www.sei.cmu.edu/reports/97hb001.pdf  
   This Carnegie Mellon study offers a table, with a range of values. Anything over 20 is considered "complex, high risk", and is the basis for the default used in this plugin. Interestingly, this guide talks in terms of "risk", rather than "complexity". See page 145:

   > | **Cyclomatic Complexity** | **Risk Evaluation** |
   > |---------------------------|---------------------|
   > | 1 - 10 | a simple program, without much risk |
   > | 11 - 20 | more complex, moderate risk |
   > | 21 - 50 | complex, high risk |
   > | greater than 50 | untestable program (very high risk) |

3. **Code Complete** - Steve McConnell  
   Steve McConnell also suggests a limit of 10. A value between 6 and 10 should be treated as a warning, and anything over 10 should be refactored.

4. **NDepend** - static analysis tool  
   http://www.ndepend.com/docs/code-metrics#CC  
   NDepend offers the following recommendation:

   > Methods where CC is higher than 15 are hard to understand and maintain. Methods where CC is higher than 30 are extremely complex and should be split into smaller methods (except if they are automatically generated by a tool). 

5. **Microsoft Code Analysis** - static analysis tool  
   https://msdn.microsoft.com/en-us/library/ms182212.aspx  
   Microsoft's code analysis tool reports a cyclomatic complexity violation when the metric is greater than 25

6. **Avoid High Cyclomatic Complexity** - Phil Koopman blog post  
   http://betterembsw.blogspot.co.uk/2014/06/avoid-high-cyclomatic-complexity.html  
   A very informative blog post discussing cyclomatic complexity, including what it is, how to avoid it, and a round up of suggested values.

This plugin uses a default value of 20. This is higher than McCabe's suggested 10 (or 15), but in line with Carnegie Mellon's suggested ranges. The value of 20 has been chosen to provide a useful initial value - not too low that a previously un-measured codebase has too many violations, and not too high that a program is too complex.
